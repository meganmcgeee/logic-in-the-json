"use strict";
const global_1 = require("./global");
const string_util_1 = require("./string-util");
const logging_helper_1 = require("./logging-helper");
const net = require("net");
let Logger = "SOCKET";
class SocketHandler {
    constructor(socket, onMessage) {
        this.socket = socket;
        this.onMessage = onMessage;
        this.buffer = "";
        this.onCloseCallback = null;
        this.connected = true;
        let self = this;
        this.onDataCallback = function (data) {
            self.handleData(data.toString());
        };
        this.socket.on("data", this.onDataCallback);
        this.socket.on("error", function (e) {
            if (self.connected) {
                logging_helper_1.LoggingHelper.debug(Logger, "SocketError From: " + self.remoteEndPoint() + " Error: " + e.code + " Message: " + e.message);
            }
        });
        this.socket.on("close", function () {
            if (self.connected) {
                if (self.onCloseCallback != null) {
                    self.onCloseCallback();
                }
                else {
                    logging_helper_1.LoggingHelper.debug(Logger, "Socket closed");
                }
            }
        });
    }
    static connect(host, port, onConnect, onMessage) {
        let socket = new net.Socket();
        let handler = new SocketHandler(socket, onMessage);
        handler.connected = false;
        socket.connect(port, host, function () {
            handler.connected = true;
            onConnect();
        });
        socket.on("error", function (error) {
            if (!handler.connected) {
                onConnect(error);
            }
        });
        return handler;
    }
    handleData(dataString) {
        if (dataString !== null) {
            this.buffer += dataString;
        }
        let delimiterIndex = this.buffer.indexOf(global_1.Global.MessageDelimiter);
        if (delimiterIndex > -1) {
            let messageIDIndex = delimiterIndex - global_1.Global.MessageIDLength;
            let badMessage = false;
            if (messageIDIndex < 0) {
                badMessage = true;
            }
            let message = this.buffer.substring(0, messageIDIndex);
            let messageIDString = this.buffer.substring(delimiterIndex - global_1.Global.MessageIDLength, delimiterIndex);
            let messageID = parseInt(messageIDString);
            if (isNaN(messageID) || (messageID + "").length < 13) {
                badMessage = true;
            }
            if (badMessage) {
                logging_helper_1.LoggingHelper.error(Logger, "Bad message received: " + dataString);
            }
            else {
                logging_helper_1.LoggingHelper.debug(Logger, "DATA READ " + this.remoteEndPoint() + " ID: " + messageID + " MSG: " + string_util_1.StringUtil.prettyPrint(message));
                this.onMessage(message, messageID);
            }
            this.buffer = this.buffer.slice(delimiterIndex + global_1.Global.MessageDelimiter.length);
            if (this.buffer.indexOf(global_1.Global.MessageDelimiter) !== -1) {
                this.handleData(null);
            }
        }
    }
    send(message, messageID) {
        if (this.socket === null) {
            logging_helper_1.LoggingHelper.warn(Logger, "Writing message to closed socket: " + messageID);
            return;
        }
        logging_helper_1.LoggingHelper.debug(Logger, "DATA SENT " + this.remoteEndPoint() + " SEQUENCE: " + messageID + " " + string_util_1.StringUtil.prettyPrint(message));
        if (messageID === undefined || messageID === null) {
            messageID = new Date().getTime();
        }
        message = message + messageID + global_1.Global.MessageDelimiter;
        this.socket.write(message, null);
    }
    remoteAddress() {
        return this.socket.remoteAddress;
    }
    remoteEndPoint() {
        if (this.socket === null) {
            return "";
        }
        return this.socket.remoteAddress + ":" + this.socket.remotePort;
    }
    disconnect() {
        if (this.isOpen()) {
            this.socket.end();
            this.socket = null;
        }
    }
    isOpen() {
        return this.socket != null;
    }
}
exports.SocketHandler = SocketHandler;
//# sourceMappingURL=socket-handler.js.map