"use strict";
const net = require("net");
const node_1 = require("./node");
const socket_handler_1 = require("../core/socket-handler");
const global_1 = require("../core/global");
const logging_helper_1 = require("../core/logging-helper");
const statistics_1 = require("./statistics");
let Logger = "NODEMGR";
class NodeManager {
    constructor(port) {
        this.port = port;
        this.host = "0.0.0.0";
        this.onConnect = null;
        this.onNodeRemoved = null;
        this.nodes = {};
    }
    node(nodeID) {
        return this.nodes[nodeID];
    }
    start(callback) {
        let self = this;
        this.server = net.createServer(function (socket) {
            let initialConnection = true;
            let node = null;
            let socketHandler = new socket_handler_1.SocketHandler(socket, function (message, messageID) {
                if (initialConnection) {
                    let connectData = null;
                    try {
                        connectData = JSON.parse(message);
                    }
                    catch (e) {
                        logging_helper_1.LoggingHelper.error(Logger, "Error on parsing initial message: " + message);
                        socketHandler.disconnect();
                        return;
                    }
                    node = new node_1.Node(connectData.id, socketHandler);
                    self.nodes[node.id] = node;
                    socketHandler.send("ACK");
                    initialConnection = false;
                    if (self.onConnect != null) {
                        self.onConnect(node);
                    }
                    statistics_1.Statistics.instance().record(node.id, statistics_1.AccessType.CONNECT);
                }
                else if (message === global_1.Global.KeepAliveMessage) {
                    NodeManager.onKeepAliveReceived(node);
                }
                else if (node.handlingRequest()) {
                    node.onReply(message, messageID);
                }
            });
            socketHandler.onCloseCallback = function () {
                if (node !== null) {
                    logging_helper_1.LoggingHelper.info(Logger, "NODE CLOSED: " + node.id);
                    delete self.nodes[node.id];
                    if (self.onNodeRemoved !== undefined && self.onNodeRemoved !== null) {
                        self.onNodeRemoved(node);
                    }
                }
            };
            logging_helper_1.LoggingHelper.info(Logger, "NODE CONNECTED: " + socket.remoteAddress + ":" + socket.remotePort);
        }).listen(this.port, this.host);
        this.server.on("listening", function () {
            if (callback !== undefined && callback !== null) {
                callback();
            }
        });
        logging_helper_1.LoggingHelper.info(Logger, "Listening on " + this.host + ":" + this.port);
    }
    static onKeepAliveReceived(node) {
        node.socketHandler.send(global_1.Global.KeepAliveMessage);
    }
    stop(callback) {
        for (let key of Object.keys(this.nodes)) {
            let node = this.node(key);
            node.socketHandler.disconnect();
            logging_helper_1.LoggingHelper.info(Logger, "NODE CLOSING: " + node.id);
        }
        this.server.close(function (error) {
            if (error !== undefined) {
                logging_helper_1.LoggingHelper.error(Logger, "ERROR! NodeManager not stopped: " + error);
            }
            else {
                logging_helper_1.LoggingHelper.info(Logger, "STOPPED");
                callback();
            }
        });
    }
}
exports.NodeManager = NodeManager;
//# sourceMappingURL=node-manager.js.map